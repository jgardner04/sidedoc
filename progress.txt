# Sidedoc TDD Progress Log

## Codebase Patterns
- Use python-docx for all docx file operations
- pytest for testing with fixtures in tests/fixtures/
- All modules should have proper type hints and pass mypy typecheck
- Use dataclasses for models (defined in models.py)
- Click framework for CLI with proper exit codes (0=success, 1=error, 2=not found, 3=invalid format, 4=sync conflict)
- Block types: heading, paragraph, list, image
- Structure.json maps content.md blocks to docx paragraph indices
- Inline formatting: bold/italic converted to markdown, underline stored in Block.inline_formatting metadata
- When processing runs, use `run.bold is True` (not just truthy check) to avoid false positives
- List detection: check for "List Bullet" and "List Number" style names
- Track list_number_counter to auto-number consecutive numbered list items
- Image detection: check for drawing elements in paragraph runs, access via doc.part.rels[rId]
- Track image_counter to generate unique filenames (image1.png, image2.png, etc.)
- extract_blocks() returns tuple: (blocks list, image_data dict) - always unpack both values
- Image roundtrip: extract saves to assets/ in ZIP, build extracts to temp dir and embeds

---

## 2026-01-13 - US-005
- What was implemented:
  - Inline formatting extraction from docx paragraphs
  - Bold text converted to **bold** markdown
  - Italic text converted to *italic* markdown
  - Bold+italic converted to ***bold italic*** markdown
  - Underline preserved in Block.inline_formatting metadata (not in markdown)
  - 5 new tests covering bold, italic, mixed formatting, and underline handling

- Files changed:
  - src/sidedoc/extract.py: Added extract_inline_formatting() function
  - src/sidedoc/reconstruct.py: Fixed type hints for mypy
  - tests/test_extract.py: Added 5 new test cases with helper function
  - progress.txt: Created initial file with codebase patterns

- **Learnings for future iterations:**
  - Pattern: When checking run formatting, use `run.bold is True` not `run.bold is not None`
    because False is a valid value that shouldn't trigger formatting
  - Pattern: Track plain text position separately from markdown position for inline_formatting metadata
  - Gotcha: python-docx paragraph.style can be None, always add null checks
  - Context: Inline formatting positions in Block.inline_formatting use plain text offsets,
    not markdown with formatting markers
  - Testing: create_formatted_docx helper makes it easy to test various formatting combinations

---

## 2026-01-13 - US-006
- What was implemented:
  - List extraction for bulleted lists (- item format)
  - List extraction for numbered lists (1. item format)
  - Auto-numbering for consecutive numbered list items
  - List type tracking to reset numbering when switching between bullets/numbers
  - 4 new tests covering bulleted, numbered, mixed lists, and lists with paragraphs

- Files changed:
  - src/sidedoc/extract.py: Added list detection logic in extract_blocks()
  - tests/test_extract.py: Added 4 new test cases with create_list_docx helper

- **Learnings for future iterations:**
  - Pattern: python-docx identifies list items by style name: "List Bullet" and "List Number"
  - Pattern: Track list_number_counter and previous_list_type to maintain proper numbering
  - Pattern: Reset numbering when encountering non-list content or switching list types
  - Context: List items are stored as separate Block objects with type="list"
  - Gotcha: Numbered lists need manual counter tracking - docx doesn't provide the number
  - Testing: create_list_docx helper simplifies creating test documents with list styles

---

## 2026-01-13 - US-007
- What was implemented:
  - Image extraction from docx paragraphs
  - Detect images via drawing elements in paragraph runs
  - Extract image data from document relationships (rId references)
  - Generate unique filenames (image1.png, image2.png, etc.)
  - Create markdown image references: ![Image N](assets/imagename.ext)
  - Store image path in Block.image_path field
  - Auto-number images with image_counter
  - 3 new tests covering single image, multiple images, and markdown format

- Files changed:
  - src/sidedoc/extract.py: Added extract_image_from_paragraph() and image handling logic
  - tests/test_extract.py: Added 3 test cases and create_minimal_png() helper

- **Learnings for future iterations:**
  - Pattern: Images detected by checking for drawing elements in paragraph runs
  - Pattern: Access image data via doc.part.rels[rId].target_part.blob
  - Pattern: Image extension from target_part.partname.split('.')[-1]
  - Pattern: Images appear as paragraphs with empty text but containing drawing elements
  - Gotcha: Image paragraphs have paragraph.text == "" but contain runs with drawings
  - Testing: create_minimal_png() generates valid minimal PNG for testing
  - Context: Each image becomes a separate Block with type="image" and image_path set
  - Pattern: Use image_counter to ensure unique filenames across document

---

## 2026-01-13 - US-017
- What was implemented:
  - Complete image roundtrip: extract → save to assets → embed in rebuilt docx
  - Modified extract_blocks() to return (blocks, image_data) tuple
  - Store image bytes in dict during extraction, save to assets/ in ZIP
  - Updated parse_markdown_to_blocks() to recognize ![alt](path) syntax
  - Created image blocks with image_path from markdown
  - Embed images in docx using doc.add_picture() from temp assets directory
  - Handle missing images with placeholder text
  - End-to-end test validates image roundtrip

- Files changed:
  - src/sidedoc/extract.py: Return tuple with image_data dict
  - src/sidedoc/package.py: Accept and write image files to assets/
  - src/sidedoc/cli.py: Pass image_data to create_sidedoc_archive
  - src/sidedoc/reconstruct.py: Parse image markdown, embed images from assets
  - tests/test_build_command.py: Added image embedding integration test
  - tests/test_extract.py: Updated all calls to unpack tuple

- **Learnings for future iterations:**
  - Pattern: extract_blocks returns (blocks, image_data) tuple - always unpack
  - Pattern: Save images to assets/ in ZIP, extract to temp dir during build
  - Pattern: Detect image markdown: line.startswith("![") and "](" in line
  - Pattern: Use tempfile.TemporaryDirectory for assets during build
  - Gotcha: parse_markdown_to_blocks must handle image blocks, not just paragraphs
  - Context: Images embedded inline with default width of 3.0 inches
  - Testing: End-to-end test extracts→builds→verifies image presence

---

## 2026-01-13 17:14 - US-020
- What was implemented:
  - Block matching algorithm for sync operations
  - Two-pass matching: first by content hash (unchanged), then by type and position (edited)
  - Identifies unchanged blocks (matched by content hash)
  - Identifies edited blocks (matched by type and exact position)
  - Identifies new blocks (no match in old blocks)
  - Identifies deleted blocks (in old blocks but no match in new)
  - Returns mapping dictionary: old block IDs → new Block objects
  - 7 comprehensive tests covering all scenarios

- Files changed:
  - src/sidedoc/sync.py: Created new module with match_blocks() function
  - tests/test_sync.py: Created 7 test cases covering all matching scenarios

- **Learnings for future iterations:**
  - Pattern: Block matching uses two-pass algorithm for accuracy
  - Pattern: First pass matches by content_hash (unchanged blocks)
  - Pattern: Second pass matches by type AND exact position (edited blocks)
  - Pattern: Return value is dict[str, Block] mapping old IDs to new blocks
  - Context: Unmatched old blocks = deletions, unmatched new blocks = additions
  - Design decision: Only match by position if type is identical (prevents false matches)
  - Design decision: Position matching requires exact index match (not fuzzy/nearest)
  - Testing: Need tests for unchanged, edited, new, deleted, and mixed scenarios
  - Gotcha: When block count stays same but content changes, algorithm treats as edits
  - Gotcha: True deletions only visible when total block count decreases

---

## 2026-01-13 19:15 - US-021
- What was implemented:
  - generate_updated_docx() function for creating docx from edited blocks
  - Matched blocks preserve formatting from styles.json (font, size, alignment)
  - New blocks receive default formatting based on block type
  - Deleted blocks omitted from output (not in new_blocks list)
  - Inline formatting parser for markdown bold (**text**) and italic (*text*)
  - apply_inline_formatting() creates runs with proper formatting
  - _parse_italic() helper for parsing italic syntax
  - 5 comprehensive tests covering all sync scenarios

- Files changed:
  - src/sidedoc/sync.py: Added generate_updated_docx, apply_inline_formatting, _parse_italic
  - tests/test_sync.py: Added 5 test cases for docx generation

- **Learnings for future iterations:**
  - Pattern: generate_updated_docx creates reverse mapping (new block -> old block ID) for style lookup
  - Pattern: Matched blocks get styles from old block ID via matches dict
  - Pattern: New blocks (not in matches) get default formatting for their type
  - Pattern: Inline formatting parsed via regex for **bold** and *italic*
  - Pattern: Create empty paragraph first, then add formatted runs for inline formatting
  - Context: Headings strip markdown markers (#) and use "Heading N" styles
  - Context: Alignment applied via WD_ALIGN_PARAGRAPH enum
  - Design decision: Simplified inline parsing (doesn't handle all edge cases)
  - Testing: Use tempfile.TemporaryDirectory for output files in tests
  - Gotcha: Font/size styling requires para.style to exist (check before applying)

---

## 2026-01-13 19:17 - US-022
- What was implemented:
  - update_sidedoc_metadata() function for updating archive metadata after sync
  - Regenerates structure.json with new block mappings and content hashes
  - Updates manifest.json modified_at timestamp (preserves created_at)
  - Updates manifest.json content_hash from new markdown content
  - Preserves styles.json and assets during repackaging
  - Atomic file replacement using temp file for safety
  - 4 comprehensive tests covering metadata updates

- Files changed:
  - src/sidedoc/sync.py: Added update_sidedoc_metadata function
  - tests/test_sync.py: Added 4 test cases for metadata updates

- **Learnings for future iterations:**
  - Pattern: Read entire archive first, preserve styles and assets, write new archive
  - Pattern: Use tempfile.NamedTemporaryFile for atomic file replacement
  - Pattern: Path.replace() for atomic move/replace on same filesystem
  - Pattern: Compute content hash with hashlib.sha256(content.encode()).hexdigest()
  - Context: Modified manifest fields: modified_at (updated), content_hash (updated)
  - Context: Preserved manifest fields: created_at, source_file, source_hash, generator
  - Design decision: Write to temp file first, then replace to avoid corruption
  - Design decision: Preserve all assets (images) automatically during repackaging
  - Testing: Create test archives with zipfile.ZipFile in tests
  - Gotcha: Must preserve assets directory structure when repackaging
  - Gotcha: Use try/finally to clean up temp files even if replacement fails

---
